<html><head><meta http-equiv="X-UA-Compatible" content="IE=edge" /><link rel="shortcut icon" href="../icons/favicon.ico" /><style type="text/css">.OH_CodeSnippetContainerTabLeftActive, .OH_CodeSnippetContainerTabLeft,.OH_CodeSnippetContainerTabLeftDisabled { }.OH_CodeSnippetContainerTabRightActive, .OH_CodeSnippetContainerTabRight,.OH_CodeSnippetContainerTabRightDisabled { }.OH_footer { }</style><link rel="stylesheet" type="text/css" href="../styles/branding.css" /><link rel="stylesheet" type="text/css" href="../styles/branding-en-US.css" /><script type="text/javascript" src="../scripts/branding.js"> </script><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Basic introduction to the capabilities of the library</title><meta name="Language" content="en-us" /><meta name="Microsoft.Help.Id" content="7404175a-f67f-479b-83f7-0e6dc75b9acf" /><meta name="Description" content="This article describes some basic stuff about LibTiff.Net" /><meta name="Microsoft.Help.ContentType" content="Concepts" /><meta name="BrandingAware" content="true" /><link type="text/css" rel="stylesheet" href="../styles/highlight.css" /><script type="text/javascript" src="../scripts/highlight.js"> </script><script type="text/javascript" src="../scripts/clipboard.min.js"></script></head><body onload="OnLoad('cs')"><input type="hidden" id="userDataCache" class="userDataStyle" /><div class="OH_outerDiv"><div class="OH_outerContent"><table class="TitleTable"><tr><td class="OH_tdTitleColumn"><h1>Basic introduction to the capabilities of the library</h1></td><td class="OH_tdRunningTitleColumn">LibTiff.Net, the managed version of the LibTiff library for reading and writing TIFF.</td></tr></table><div id="mainSection"><div id="mainBody"><span class="introStyle"></span> <div class="introduction"><p>This article describes some basic stuff about LibTiff.Net</p></div><div class="OH_CollapsibleAreaRegion" id="SubSection1"><div class="OH_regiontitle">Error Handling</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            LibTiff.Net handles most errors by returning an invalid/erroneous
                            value when returning from a function call. Various diagnostic messages
                            may also be generated by the library. All error and warning messages
                            are directed to a single global error handler object that can be
                            specified with a call to
                            <a href="1cc52bda-c37c-3653-427e-18ec3fc51bae.htm">SetErrorHandler(TiffErrorHandler)</a>.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection2"><div class="OH_regiontitle">Basic File Handling</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            The library (like libtiff) is modeled after the normal stdio library.
                            For example, to read from an existing TIFF image the file must first 
                            be opened:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAFAJAAAAA_tabimgleft"> </div><div id="ID0EAFAJAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAFAJAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAFAJAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAFAJAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAFAJAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve">Tiff image = Tiff.Open(<span class="highlight-literal">"foo.tif"</span>, <span class="highlight-literal">"r"</span>)
<span class="highlight-comment">// ... do stuff ...</span>
image.Close(); <span class="highlight-comment">// or image.Dispose();</span></pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAFAJAAAAA");</script><p>
                            To create or overwrite a TIFF image the file is also opened, but
                            with a "w" argument:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EADAJAAAAA_tabimgleft"> </div><div id="ID0EADAJAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EADAJAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EADAJAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EADAJAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EADAJAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve">Tiff image = Tiff.Open(<span class="highlight-literal">"foo.tif"</span>, <span class="highlight-literal">"w"</span>)
<span class="highlight-comment">// ... do stuff ...</span>
image.Close(); <span class="highlight-comment">// or image.Dispose();</span></pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EADAJAAAAA");</script><p>
                            If the file already exists it is first truncated to zero length.
                        </p><div class="alert"><table><tr><th><img src="../icons/alert_note.gif" alt="Note" /> Note</th></tr><tr><td><p>
                                TIFF image files may not be opened for both reading and writing
                                by LibTiff.Net; there is no support for altering the contents of
                                a TIFF file.
                            </p></td></tr></table></div><p>
                            LibTiff.Net buffers much information associated with writing a valid
                            TIFF image. You should dispose all
                            <a href="f7e0a767-6f44-b6cb-1239-6a309ddf9ae7.htm">Tiff</a>
                            objects. When writing a TIFF image it is especcialy important.
                            You can also call
                            <a href="9bc26d59-9084-795c-2325-9d29069f7db2.htm">Close<span id="LST4A38FA97_0"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_0?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            at any time to close image (note that image is automatically closed
                            during disposal). You can flush buffered data at any time using 
                            <a href="14b42cfd-08c7-7725-c289-9b077621410e.htm">Flush<span id="LST4A38FA97_1"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_1?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection3"><div class="OH_regiontitle">TIFF Directories</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            TIFF supports the storage of multiple images in a single file. Each
                            image has an associated data structure termed a
                            <em>directory</em> that houses all the information
                            about the format and content of the image data. Images in a file are
                            usually related but they do not need to be; it is perfectly alright to
                            store a color image together with a black and white image. Note
                            however that while images may be related their directories are not.
                            That is, each directory stands on its own; their is no need to read an
                            unrelated directory in order to properly interpret the contents of
                            an image.
                        </p><p>
                            LibTiff.Net provides several routines for reading and writing
                            directories. In normal use there is no need to explicitly read or
                            write a directory: the library automatically reads the first directory
                            in a file when opened for reading, and directory information to be
                            written is automatically accumulated and written when writing
                            (assuming
                            <a href="7755ac80-49ba-f2e5-1de5-1dd3f589ce7b.htm">Dispose<span id="LST4A38FA97_2"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_2?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>,
                            <a href="9bc26d59-9084-795c-2325-9d29069f7db2.htm">Close<span id="LST4A38FA97_3"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_3?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> or
                            <a href="14b42cfd-08c7-7725-c289-9b077621410e.htm">Flush<span id="LST4A38FA97_4"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_4?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            are called).
                        </p><p>
                            For a file open for reading the
                            <a href="29e2caf0-871a-b2e3-3c8f-3d365627d047.htm">SetDirectory(Int16)</a>
                            method can be used to select an arbitrary directory; directories are
                            referenced by number with the numbering starting at 0. Otherwise the
                            <a href="32d714d8-3e76-b61c-7c29-cd5dc08141bd.htm">ReadDirectory<span id="LST4A38FA97_5"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_5?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> and
                            <a href="20b69324-919e-ce8c-763a-d0c935708789.htm">WriteDirectory<span id="LST4A38FA97_6"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_6?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            methods can be used for sequential access to directories. For example,
                            to count the number of directories in a file the following code
                            might be used:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EACAIAAAAA_tabimgleft"> </div><div id="ID0EACAIAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EACAIAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EACAIAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EACAIAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EACAIAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> CountTiffDirectories
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                <span class="highlight-keyword">int</span> dircount = <span class="highlight-number">0</span>;
                <span class="highlight-keyword">do</span>
                {
                    dircount++;
                } <span class="highlight-keyword">while</span> (image.ReadDirectory());

                System.Console.Out.WriteLine(<span class="highlight-literal">"{0} directories in {1}"</span>, dircount, args[<span class="highlight-number">0</span>]);
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EACAIAAAAA");</script><p>
                            Finally, note that there are couple of methods for querying the
                            directory status of an open file:
                            <a href="09316c3d-c073-4306-7579-4e237d8232e1.htm">CurrentDirectory<span id="LST4A38FA97_7"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_7?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> and
                            <a href="d59e2fe0-0610-bddc-8e58-00e1a19fda32.htm">LastDirectory<span id="LST4A38FA97_8"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_8?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>.
                        </p><p>
                            There is also
                            <a href="7132cc6b-fd05-1337-ece3-c266b92b270c.htm">PrintDirectory<span id="LST4A38FA97_9"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_9?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            that can be called to print a formatted description of the
                            contents of the current directory.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection4"><div class="OH_regiontitle">TIFF Tags</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            Image-related information such as the image width and height, number
                            of samples, orientation, colorimetric information, etc. are stored in
                            each image directory in <em>fields</em> or
                            <em>tags</em>. Tags are identified by a number
                            that is usually a value registered with the Aldus (now Adobe)
                            Corporation. LibTiff.Net uses
                            <a href="004b29cb-3828-19ac-b924-95671b477f08.htm">TiffTag</a>
                            enumeration instead of numbers to make code much more readable and
                            understandable. Beware however that some vendors write TIFF
                            images with tags that are unregistered; in this case interpreting
                            their contents is usually a waste of time.
                        </p><p>
                            LibTiff.Net reads the contents of a directory all at once and converts
                            the on-disk information to an appropriate in-memory form. While the
                            TIFF specification permits an arbitrary set of tags to be defined and
                            used in a file, the library only understands a limited set of tags.
                            Any unknown tags that are encountered in a file are ignored. There is
                            a mechanism to extend the set of tags the library handles without
                            modifying the library itself; this is described in
                            <a href="e0ed9e8f-4b0e-4480-9693-fbf731ed3b2f.htm">Adding new (custom) tags</a>
                            article.
                        </p><p>
                            LibTiff.Net provides two methods for getting and setting tag values:
                            <a href="1bd1b3b8-a2ea-9d24-66ef-38ffdd33b984.htm">GetField(TiffTag)</a> and
                            <a href="87815022-38e5-9d3e-2ab5-01af3c9077ae.htm">SetField(TiffTag, <span id="LST4A38FA97_10"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_10?cpp=array&lt;");</script>Object<span id="LST4A38FA97_11"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_11?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>)</a>.
                            The GetField method returns array of
                            <a href="0967a036-4800-ebd2-d23d-95356a377826.htm">FieldValue</a>
                            objects. The array has length equal to number of tag values. If the
                            array is null then tag is not defined in the directory. The SetField
                            method accepts variable number of tag values as arguments. The TIFF
                            specification defines <em>default values</em> for
                            some tags. To get the value of a tag, or its default value if it is
                            undefined, the
                            <a href="9f3018bf-0470-6c36-2299-fd8ceff56062.htm">GetFieldDefaulted(TiffTag)</a>
                            method may be used.
                        </p><p>
                            You may want to consult
                            "<a href="54cbd23d-dc55-44b9-921f-3a06efc2f6ce.htm">Well-known tags and their value(s) data types</a>" to become
                            familiar with exact data types and calling conventions required for
                            each tag supported by the library.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection5"><div class="OH_regiontitle">TIFF Compression Schemes</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            LibTiff.Net includes support for a wide variety of data compression
                            schemes. In normal operation a compression scheme is automatically used
                            when the
                            <a href="004b29cb-3828-19ac-b924-95671b477f08.htm">TiffTag</a>.COMPRESSION
                            tag is set, either by opening a file for reading, or by setting the
                            tag when writing.
                        </p><p>
                            Compression schemes are implemented by software modules termed
                            <em>codecs</em> that implement decoder and encoder
                            methods that hook into the core library i/o support. Codecs other than
                            those bundled with the library can be registered for use with the
                            <a href="40ee20a0-64de-2854-a14c-8664db9ecff8.htm">RegisterCodec(TiffCodec)</a>
                            method. This method can also be used to override the core-library
                            implementation for a compression scheme.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection6"><div class="OH_regiontitle">Byte Order</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            The TIFF specification says, and has always said, that a
                            <em>correct TIFF reader must handle images in big-endian and
                            little-endian byte order</em>. LibTiff.Net conforms in this
                            respect. Consequently there is no means to force a specific byte order
                            for the data written to a TIFF image file (data is written in the
                            native order of the host CPU unless appending to an existing file, in
                            which case it is written in the byte order specified in the file).
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection7"><div class="OH_regiontitle">Data Placement</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            The TIFF specification requires that all information except an 8-byte
                            header can be placed anywhere in a file. In particular, it is
                            perfectly legitimate for directory information to be written after the
                            image data itself. Software that require that data be organized in a
                            file in a particular order (e.g. directory information before image
                            data) does not correctly support TIFF. LibTiff.Net provides no
                            mechanism for controlling the placement of data in a file; image data
                            is typically written before directory information.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection8"><div class="OH_regiontitle">RGBA Image Support</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            LibTiff.Net provides a high-level interface for reading image data
                            from a TIFF file. This interface handles the details of data
                            organization and format for a wide variety of TIFF files; at least the
                            large majority of those files that one would normally encounter. Image
                            data is, by default, returned as ABGR pixels packed into 32-bit words
                            (8 bits per sample). Rectangular rasters can be read or data can be
                            intercepted at an intermediate level and packed into memory in a
                            format more suitable to the application. The library handles all the
                            details of the format of data stored on disk and, in most cases, if
                            any colorspace conversions are required: bilevel to RGB, greyscale to
                            RGB, CMYK to RGB, YCbCr to RGB, 16-bit samples to 8-bit samples,
                            associated/unassociated alpha, etc.
                        </p><p>
                            There are two ways to read image data using this interface. If all the
                            data is to be stored in memory and manipulated at once, then the
                            <a href="a36a7f7d-899e-9956-745a-25adf1c7f9ac.htm">ReadRGBAImage<span id="LST4A38FA97_12"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_12?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> or
                            <a href="93087c97-6d28-7886-75da-1611cc78d023.htm">ReadRGBAImageOriented<span id="LST4A38FA97_13"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_13?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            can be used:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAGADAAAAA_tabimgleft"> </div><div id="ID0EAGADAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAGADAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAGADAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAGADAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAGADAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> UsingReadRgbaImage
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                FieldValue[] <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGEWIDTH);
                <span class="highlight-keyword">int</span> width = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGELENGTH);
                <span class="highlight-keyword">int</span> height = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">int</span> imageSize = height * width;
                <span class="highlight-keyword">int</span>[] raster = <span class="highlight-keyword">new</span> <span class="highlight-keyword">int</span>[imageSize];

                <span class="highlight-keyword">if</span> (image.ReadRGBAImage(width, height, raster))
                {
                    <span class="highlight-comment">// ...process raster data...</span>
                }

                image.Close();
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAGADAAAAA");</script><p>
                            Alternatively,
                            <a href="a36a7f7d-899e-9956-745a-25adf1c7f9ac.htm">ReadRGBAImage<span id="LST4A38FA97_14"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_14?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            can be replaced with a more low-level interface that permits an
                            application to have more control over this reading procedure. The
                            equivalent to the above is:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAEADAAAAA_tabimgleft"> </div><div id="ID0EAEADAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAEADAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAEADAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAEADAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAEADAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> UsingTiffRgbaImage
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff tif = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (tif == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                <span class="highlight-keyword">string</span> errorMsg;
                TiffRgbaImage img = TiffRgbaImage.Create(tif, <span class="highlight-keyword">false</span>, <span class="highlight-keyword">out</span> errorMsg);
                <span class="highlight-keyword">if</span> (img == <span class="highlight-keyword">null</span>)
                {
                    System.Console.Error.WriteLine(errorMsg);
                    <span class="highlight-keyword">return</span>;
                }

                <span class="highlight-keyword">int</span> rasterSize = img.Width * img.Height;
                <span class="highlight-keyword">int</span>[] raster = <span class="highlight-keyword">new</span> <span class="highlight-keyword">int</span>[rasterSize];
                <span class="highlight-keyword">if</span> (img.GetRaster(raster, <span class="highlight-number">0</span>, img.Width, img.Height))
                {
                    <span class="highlight-comment">// ...process raster data...</span>
                }
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAEADAAAAA");</script><p>
                            However this usage does not take advantage of the more fine-grained
                            control that's possible. That is, by using this interface it is
                            possible to:
                            <ul><li><p>
                                        repeatedly fetch (and manipulate) an image without opening
                                        and closing the file
                                    </p></li><li><p>
                                        interpose a method for packing raster pixel data according
                                        to application-specific needs (or write the data at all)
                                    </p></li><li><p>
                                        interpose methods that handle TIFF formats that are not
                                        already handled by the core library
                                    </p></li></ul></p><p>
                            The first item means that, for example, image viewers that want to
                            handle multiple files can cache decoding information in order to
                            speedup the work required to display a TIFF image.
                        </p><p>
                            The second item is the main reason for this interface. By interposing a
                            <a href="2941cecb-ffb1-865a-551c-8ca4985885fc.htm">PutContig</a> and
                            <a href="1d1db6ae-9df9-1f42-0d7f-57fcf959f339.htm">PutSeparate</a>
                            (the methods that are called to pack pixel data in the raster) it is
                            possible share the core logic that understands how to deal with TIFF
                            while packing the resultant pixels in a format that is optimized for
                            the application. This alternate format might be very different than
                            the 8-bit per sample ABGR format the library writes by default. For
                            example, if the application is going to display the image on an 8-bit
                            colormap display the put routine might take the data and convert it
                            on-the-fly to the best colormap indices for display.
                        </p><p>
                            The last item permits an application to extend the library without
                            modifying the core code. By overriding the code provided an application
                            might add support for some esoteric flavor of TIFF that it needs, or
                            it might substitute a packing routine that is able to do optimizations
                            using application/environment-specific information.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection9"><div class="OH_regiontitle">Scanline-based Image I/O</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            The simplest interface provided by LibTiff.Net is a scanline-oriented
                            interface that can be used to read TIFF images that have their image
                            data organized in strips (trying to use this interface to read data
                            written in tiles will produce errors.) A scanline is a one pixel high
                            row of image data whose width is the width of the image. Data is
                            returned packed if the image data is stored with samples packed
                            together, or as arrays of separate samples if the data is stored with
                            samples separated. The major limitation of the scanline-oriented
                            interface, other than the need to first identify an existing file as
                            having a suitable organization, is that random access to individual
                            scanlines can only be provided when data is not stored in a compressed
                            format, or when the number of rows in a strip of image data is set to one 
                            (<a href="004b29cb-3828-19ac-b924-95671b477f08.htm">TiffTag</a>.ROWSPERSTRIP
                            is one).
                        </p><p>
                            Two methods are provided for scanline-based i/o:
                            <a href="af6c32ae-4afb-888c-fde0-aa19085a3002.htm">ReadScanline<span id="LST4A38FA97_15"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_15?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> and
                            <a href="db0aa987-8e75-5a3e-5fec-1af1e2749968.htm">WriteScanline<span id="LST4A38FA97_16"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_16?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>.
                            For example, to read the contents of a file that is assumed to be
                            organized in strips, the following might be used:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAFACAAAAA_tabimgleft"> </div><div id="ID0EAFACAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAFACAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAFACAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAFACAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAFACAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadScanlines
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                FieldValue[] <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGELENGTH);
                <span class="highlight-keyword">int</span> imageLength = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[image.ScanlineSize()];
                <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> row = <span class="highlight-number">0</span>; row &lt; imageLength; row++)
                    image.ReadScanline(buf, row);
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAFACAAAAA");</script><p><a href="e40cc5fe-b2f4-39e5-abc8-835346507d18.htm">ScanlineSize<span id="LST4A38FA97_17"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_17?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>
                            returns the number of bytes in a decoded scanline, as returned by
                            <a href="af6c32ae-4afb-888c-fde0-aa19085a3002.htm">ReadScanline<span id="LST4A38FA97_18"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_18?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>.
                            Note however that if the file had been create with samples written in
                            separate planes, then the above code would only read data that
                            contained the first sample of each pixel; to handle either case one
                            might use the following instead:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EADACAAAAA_tabimgleft"> </div><div id="ID0EADACAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EADACAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EADACAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EADACAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EADACAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadSeparatedScanlines
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                FieldValue[] <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGELENGTH);
                <span class="highlight-keyword">int</span> imageLength = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">value</span> = image.GetField(TiffTag.PLANARCONFIG);
                PlanarConfig config = (PlanarConfig)<span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[image.ScanlineSize()];

                <span class="highlight-keyword">if</span> (config == PlanarConfig.CONTIG)
                {
                    <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> row = <span class="highlight-number">0</span>; row &lt; imageLength; row++)
                        image.ReadScanline(buf, row);
                }
                <span class="highlight-keyword">else</span> <span class="highlight-keyword">if</span> (config == PlanarConfig.SEPARATE)
                {
                    <span class="highlight-keyword">value</span> = image.GetField(TiffTag.SAMPLESPERPIXEL);
                    <span class="highlight-keyword">short</span> spp = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToShort();

                    <span class="highlight-keyword">for</span> (<span class="highlight-keyword">short</span> s = <span class="highlight-number">0</span>; s &lt; spp; s++)
                    {
                        <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> row = <span class="highlight-number">0</span>; row &lt; imageLength; row++)
                            image.ReadScanline(buf, row, s);
                    }
                }
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EADACAAAAA");</script><p>
                            Beware however that if the following code were used instead to read
                            data in the case config == PlanarConfig.SEPARATE,...
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EABACAAAAA_tabimgleft"> </div><div id="ID0EABACAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EABACAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EABACAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EABACAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EABACAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> row = <span class="highlight-number">0</span>; row &lt; imageLength; row++)
{
    <span class="highlight-keyword">for</span> (<span class="highlight-keyword">short</span> s = <span class="highlight-number">0</span>; s &lt; spp; s++)
        image.ReadScanline(buf, row, s);
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EABACAAAAA");</script><p>
                            ...then problems would arise if TiffTag.ROWSPERSTRIP was not one
                            because the order in which scanlines are requested would require
                            random access to data within strips (something that is not supported
                            by the library when strips are compressed).
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection10"><div class="OH_regiontitle">Strip-oriented Image I/O</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            The strip-oriented interfaces provided by the library provide access
                            to entire strips of data. Unlike the scanline-oriented calls, data can
                            be read or written compressed or uncompressed. Accessing data at a
                            strip (or tile) level is often desirable because there are no
                            complications with regard to random access to data within strips.
                        </p><p>
                            A simple example of reading an image by strips is:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAGABAAAAA_tabimgleft"> </div><div id="ID0EAGABAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAGABAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAGABAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAGABAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAGABAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadStrips
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[image.StripSize()];
                <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> strip = <span class="highlight-number">0</span>; strip &lt; image.NumberOfStrips(); strip++)
                    image.ReadEncodedStrip(strip, buf, <span class="highlight-number">0</span>, <span class="highlight-number">-1</span>);
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAGABAAAAA");</script><p>
                            Notice how a strip size of -1 is used;
                            <a href="2d0ecc5f-7777-71d3-f4c2-d0bfad681c5e.htm">ReadEncodedStrip(Int32, <span id="LST4A38FA97_19"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_19?cpp=array&lt;");</script>Byte<span id="LST4A38FA97_20"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_20?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>, Int32, Int32)</a>
                            will calculate the appropriate size in this case.
                        </p><p>
                            The above code reads strips in the order in which the data is
                            physically stored in the file. If multiple samples are present and
                            data is stored with
                            <a href="d2e12021-da72-b32f-b558-dc23d914d698.htm">PlanarConfig</a>.SEPARATE
                            then all the strips of data holding the first sample will be read,
                            followed by strips for the second sample, etc.
                        </p><p>
                            Finally, note that the last strip of data in an image may have fewer
                            rows in it than specified by the TiffTag.ROWSPERSTRIP. A reader should
                            not assume that each decoded strip contains a full set of rows in it.
                        </p><p>
                            The following is an example of how to read raw strips of data from a file:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EABABAAAAA_tabimgleft"> </div><div id="ID0EABABAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EABABAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EABABAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EABABAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EABABAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadRawStrips
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                FieldValue[] <span class="highlight-keyword">value</span> = image.GetField(TiffTag.STRIPBYTECOUNTS);
                <span class="highlight-keyword">int</span>[] byteCounts = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToIntArray();
                <span class="highlight-keyword">int</span> stripSize = byteCounts[<span class="highlight-number">0</span>];

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[stripSize];
                <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> strip = <span class="highlight-number">0</span>; strip &lt; image.NumberOfStrips(); strip++)
                {
                    <span class="highlight-keyword">if</span> (byteCounts[strip] &gt; stripSize)
                    {
                        stripSize = byteCounts[strip];
                        buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[stripSize];
                    }

                    image.ReadRawStrip(strip, buf, <span class="highlight-number">0</span>, stripSize);
                }
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EABABAAAAA");</script><p>
                            As above the strips are read in the order in which they are physically
                            stored in the file; this may be different from the logical ordering
                            expected by an application.
                        </p><div class="OH_CollapsibleAreaRegion" id="SubSection11"><div class="OH_regiontitle">Tile-oriented Image I/O</div><div class="OH_CollapsibleArea_HrDiv"><hr class="OH_CollapsibleArea_Hr" /></div></div><div class="OH_clear"> </div><p>
                            Tiles of data may be read and written in a manner similar to strips.
                            With this interface, an image is broken up into a set of rectangular
                            areas that may have dimensions less than the image width and height.
                            All the tiles in an image have the same size, and the tile width and
                            length must each be a multiple of 16 pixels. Tiles are ordered
                            left-to-right and top-to-bottom in an image. As for scanlines, samples
                            can be packed contiguously or separately. When separated, all the
                            tiles for a sample are colocated in the file. That is, all the tiles
                            for sample 0 appear before the tiles for sample 1, etc.
                        </p><p>
                            Tiles and strips may also be extended in a z dimension to form
                            volumes. Data volumes are organized as "slices". That is, all the data
                            for a slice is colocated. Volumes whose data is organized in tiles can
                            also have a tile depth so that data can be organized in cubes.
                        </p><p>
                            There are actually two interfaces for tiles. One interface is similar
                            to scanlines, to read a tiled image, code of the following sort might
                            be used:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EADAAAAAAA_tabimgleft"> </div><div id="ID0EADAAAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EADAAAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EADAAAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EADAAAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EADAAAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadTiles
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                FieldValue[] <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGEWIDTH);
                <span class="highlight-keyword">int</span> imageWidth = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">value</span> = image.GetField(TiffTag.IMAGELENGTH);
                <span class="highlight-keyword">int</span> imageLength = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">value</span> = image.GetField(TiffTag.TILEWIDTH);
                <span class="highlight-keyword">int</span> tileWidth = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">value</span> = image.GetField(TiffTag.TILELENGTH);
                <span class="highlight-keyword">int</span> tileLength = <span class="highlight-keyword">value</span>[<span class="highlight-number">0</span>].ToInt();

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[image.TileSize()];
                <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> y = <span class="highlight-number">0</span>; y &lt; imageLength; y += tileLength)
                {
                    <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> x = <span class="highlight-number">0</span>; x &lt; imageWidth; x += tileWidth)
                        image.ReadTile(buf, <span class="highlight-number">0</span>, x, y, <span class="highlight-number">0</span>, <span class="highlight-number">0</span>);
                }
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EADAAAAAAA");</script><p>
                            (once again, we assume samples are packed contiguously).
                        </p><p>
                            Alternatively a direct interface to the low-level data is provided a
                            la strips. Tiles can be read with
                            <a href="44229155-25ca-5d8c-0058-0aa6e35a0b55.htm">ReadEncodedTile(Int32, <span id="LST4A38FA97_21"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_21?cpp=array&lt;");</script>Byte<span id="LST4A38FA97_22"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_22?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>, Int32, Int32)</a> or
                            <a href="ea790cce-fa51-f9b3-6cc8-ff5feacc6e1d.htm">ReadRawTile(Int32, <span id="LST4A38FA97_23"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_23?cpp=array&lt;");</script>Byte<span id="LST4A38FA97_24"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_24?cpp=&gt;|cs=[]|vb=()|nu=[]|fs=[]");</script>, Int32, Int32)</a>,
                            and written with
                            <a href="6f378a2a-bf2b-f83b-4798-7d2e5181bed7.htm">WriteEncodedTile<span id="LST4A38FA97_25"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_25?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a> or
                            <a href="e7803430-0f05-b8cf-c2d0-f5b1c5ab39bf.htm">WriteRawTile<span id="LST4A38FA97_26"></span><script type="text/javascript">AddLanguageSpecificTextSet("LST4A38FA97_26?cs=()|vb=|cpp=()|nu=()|fs=()");</script></a>.
                            For example, to read all the tiles in an image:
                        </p><div class="OH_CodeSnippetContainer"><div class="OH_CodeSnippetContainerTabs"><div class="OH_CodeSnippetContainerTabLeftActive" id="ID0EAAAAAAAAA_tabimgleft"> </div><div id="ID0EAAAAAAAAA_tab1" class="OH_CodeSnippetContainerTabSolo">C#</div><div class="OH_CodeSnippetContainerTabRightActive" id="ID0EAAAAAAAAA_tabimgright"> </div></div><div class="OH_CodeSnippetContainerCodeCollection"><div class="OH_CodeSnippetToolBar"><div class="OH_CodeSnippetToolBarText"><a id="ID0EAAAAAAAAA_copyCode" href="#" class="OH_copyCodeSnippet" onclick="javascript:CopyToClipboard('ID0EAAAAAAAAA');return false;" title="Copy">Copy</a></div></div><div id="ID0EAAAAAAAAA_code_Div1" class="OH_CodeSnippetContainerCode" style="display: block"><pre xml:space="preserve"><span class="highlight-keyword">using</span> BitMiracle.LibTiff.Classic;

<span class="highlight-keyword">namespace</span> ReadEncodedTile
{
    <span class="highlight-keyword">class</span> Program
    {
        <span class="highlight-keyword">static</span> <span class="highlight-keyword">void</span> Main(<span class="highlight-keyword">string</span>[] args)
        {
            <span class="highlight-keyword">using</span> (Tiff image = Tiff.Open(args[<span class="highlight-number">0</span>], <span class="highlight-literal">"r"</span>))
            {
                <span class="highlight-keyword">if</span> (image == <span class="highlight-keyword">null</span>)
                    <span class="highlight-keyword">return</span>;

                <span class="highlight-keyword">byte</span>[] buf = <span class="highlight-keyword">new</span> <span class="highlight-keyword">byte</span>[image.TileSize()];
                <span class="highlight-keyword">for</span> (<span class="highlight-keyword">int</span> tile = <span class="highlight-number">0</span>; tile &lt; image.NumberOfTiles(); tile++)
                    image.ReadEncodedTile(tile, buf, <span class="highlight-number">0</span>, <span class="highlight-number">-1</span>);
            }
        }
    }
}</pre></div></div></div><script type="text/javascript">AddLanguageTabSet("ID0EAAAAAAAAA");</script></div></div></div></div><div id="OH_footer" class="OH_footer"><p><a href="http://www.bitmiracle.com/libtiff" target="_blank">Copyright © 2008-2013 Bit Miracle. All rights reserved.</a></p><div class="OH_feedbacklink">Send comments on this topic to
        <a id="HT_MailLink" href="mailto:support%40bitmiracle.com?Subject=LibTiff.Net, the managed version of the LibTiff library for reading and writing TIFF.">support@bitmiracle.com</a></div>
        <script type="text/javascript">
        var HT_mailLink = document.getElementById("HT_MailLink");
        var HT_mailLinkText = HT_mailLink.innerHTML;
        HT_mailLink.href += ": " + document.title + "\u0026body=" + encodeURIComponent("Your feedback is used to improve the documentation and the product. Your e-mail address will not be used for any other purpose and is disposed of after the issue you report is resolved. While working to resolve the issue that you report, you may be contacted via e-mail to get further details or clarification on the feedback you sent. After the issue you report has been addressed, you may receive an e-mail to let you know that your feedback has been addressed.");
        HT_mailLink.innerHTML = HT_mailLinkText;
        </script></div></body></html>